<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CHAI 3D: cProxyPointForceAlgo Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>cProxyPointForceAlgo Class Reference</h1><!-- doxytag: class="cProxyPointForceAlgo" --><!-- doxytag: inherits="cGenericPointForceAlgo" -->Implements the finger-proxy algorithm for computing interaction forces between a point force device and meshes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;CProxyPointForceAlgo.h&gt;</code>
<p>
<p>Inheritance diagram for cProxyPointForceAlgo:
<p><center><img src="classc_proxy_point_force_algo.png" usemap="#cProxyPointForceAlgo_map" border="0" alt=""></center>
<map name="cProxyPointForceAlgo_map">
<area href="classc_generic_point_force_algo.html" alt="cGenericPointForceAlgo" shape="rect" coords="0,0,152,24">
</map>
<a href="classc_proxy_point_force_algo-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e2d00616ad7692c57a06133bfc56631e">cProxyPointForceAlgo</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="classc_proxy_point_force_algo.html" title="Implements the finger-proxy algorithm for computing interaction forces between a...">cProxyPointForceAlgo</a>.  <a href="#e2d00616ad7692c57a06133bfc56631e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d7d138be171b9fc353b61d3f53c47d05">initialize</a> (<a class="el" href="classc_world.html">cWorld</a> *a_world, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_initialPos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the algorithm.  <a href="#d7d138be171b9fc353b61d3f53c47d05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#ac323ed55414943dfeb8469a9ff07b4c">computeForces</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_nextDevicePos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate interaction forces between device and meshes.  <a href="#ac323ed55414943dfeb8469a9ff07b4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d02e484b3da0ed2ea586a379964fd56a"></a><!-- doxytag: member="cProxyPointForceAlgo::setProxyRadius" ref="d02e484b3da0ed2ea586a379964fd56a" args="(const double a_radius)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d02e484b3da0ed2ea586a379964fd56a">setProxyRadius</a> (const double a_radius)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set radius of proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02a615c227f04067ee2e6b03b4c55a52"></a><!-- doxytag: member="cProxyPointForceAlgo::getProxyRadius" ref="02a615c227f04067ee2e6b03b4c55a52" args="() const" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#02a615c227f04067ee2e6b03b4c55a52">getProxyRadius</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read radius of proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f595d174dfb0e6faee7e8752ae3c6a0c"></a><!-- doxytag: member="cProxyPointForceAlgo::getProxyGlobalPosition" ref="f595d174dfb0e6faee7e8752ae3c6a0c" args="() const" -->
virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#f595d174dfb0e6faee7e8752ae3c6a0c">getProxyGlobalPosition</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last computed position of proxy in world coordinates. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="498c33ed60ed5be0aa31fda5ba3c8456"></a><!-- doxytag: member="cProxyPointForceAlgo::getDeviceGlobalPosition" ref="498c33ed60ed5be0aa31fda5ba3c8456" args="() const" -->
virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#498c33ed60ed5be0aa31fda5ba3c8456">getDeviceGlobalPosition</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last specified position of device in world coordinates. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c5714ad73b8c20f3bed9b1fa42de4bd"></a><!-- doxytag: member="cProxyPointForceAlgo::getLastGlobalForce" ref="5c5714ad73b8c20f3bed9b1fa42de4bd" args="() const" -->
virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#5c5714ad73b8c20f3bed9b1fa42de4bd">getLastGlobalForce</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last computed global force vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#3286106325b865928794abca48bee562">getContacts</a> (<a class="el" href="classc_triangle.html">cTriangle</a> *&amp;a_t0, <a class="el" href="classc_triangle.html">cTriangle</a> *&amp;a_t1, <a class="el" href="classc_triangle.html">cTriangle</a> *&amp;a_t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of current contacts and the associated triangles.  <a href="#3286106325b865928794abca48bee562"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="002ce12a42e903d8c2734360222a02b0"></a><!-- doxytag: member="cProxyPointForceAlgo::getContactObject" ref="002ce12a42e903d8c2734360222a02b0" args="()" -->
virtual <a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#002ce12a42e903d8c2734360222a02b0">getContactObject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the object with which device is currently in contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d88cb7b49256e78c6f848fd0192c35a"></a><!-- doxytag: member="cProxyPointForceAlgo::getContactPoint" ref="4d88cb7b49256e78c6f848fd0192c35a" args="()" -->
virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#4d88cb7b49256e78c6f848fd0192c35a">getContactPoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return point of contact between proxy and object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2dc962996a5616fb0cf758553c96d21f"></a><!-- doxytag: member="cProxyPointForceAlgo::getContactObjectLastGlobalPos" ref="2dc962996a5616fb0cf758553c96d21f" args="(cVector3d &amp;a_pos)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#2dc962996a5616fb0cf758553c96d21f">getContactObjectLastGlobalPos</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global position of object with which device last contacted. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="674ab2c31f39af440d94f9f4442d6c6f"></a><!-- doxytag: member="cProxyPointForceAlgo::getContactObjectLastGlobalRot" ref="674ab2c31f39af440d94f9f4442d6c6f" args="(cMatrix3d &amp;a_rot)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#674ab2c31f39af440d94f9f4442d6c6f">getContactObjectLastGlobalRot</a> (<a class="el" href="structc_matrix3d.html">cMatrix3d</a> &amp;a_rot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global rotation of object with which device last contacted. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d153722a144bd15a951f1917efd3730"></a><!-- doxytag: member="cProxyPointForceAlgo::enableDynamicProxy" ref="4d153722a144bd15a951f1917efd3730" args="(bool a_enable)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#4d153722a144bd15a951f1917efd3730">enableDynamicProxy</a> (bool a_enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set dynamic proxy flag, (if on, all contacts are computed in object-local space). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d75fcc0205d7aa551b00fa7154efba1"></a><!-- doxytag: member="cProxyPointForceAlgo::getDynamicProxyEnabled" ref="8d75fcc0205d7aa551b00fa7154efba1" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#8d75fcc0205d7aa551b00fa7154efba1">getDynamicProxyEnabled</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether the dynamic proxy flag is on. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0690bfdb8da949df035c3f68a9d49eb6"></a><!-- doxytag: member="cProxyPointForceAlgo::getNormalForce" ref="0690bfdb8da949df035c3f68a9d49eb6" args="()" -->
virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#0690bfdb8da949df035c3f68a9d49eb6">getNormalForce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return most recently calculated normal force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3c97a1c2fa07489eb068176b335b202"></a><!-- doxytag: member="cProxyPointForceAlgo::getTangentialForce" ref="c3c97a1c2fa07489eb068176b335b202" args="()" -->
virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#c3c97a1c2fa07489eb068176b335b202">getTangentialForce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return most recently calculated tangential force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd8c54482d80c49c55b2e3411f6284d9"></a><!-- doxytag: member="cProxyPointForceAlgo::setUseFriction" ref="cd8c54482d80c49c55b2e3411f6284d9" args="(const bool &amp;a_useFriction)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#cd8c54482d80c49c55b2e3411f6284d9">setUseFriction</a> (const bool &amp;a_useFriction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether friction is used. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e824b14a6d973a0f3478693a8d71211b"></a><!-- doxytag: member="cProxyPointForceAlgo::setUseZillesFriction" ref="e824b14a6d973a0f3478693a8d71211b" args="(const bool &amp;a_useZillesFriction)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e824b14a6d973a0f3478693a8d71211b">setUseZillesFriction</a> (const bool &amp;a_useZillesFriction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether Zilles friction is used. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6e10a818b8457701ce3a71ad6e0a190"></a><!-- doxytag: member="cProxyPointForceAlgo::setUseMelderFriction" ref="e6e10a818b8457701ce3a71ad6e0a190" args="(const bool &amp;a_useMelderFriction)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e6e10a818b8457701ce3a71ad6e0a190">setUseMelderFriction</a> (const bool &amp;a_useMelderFriction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether Melder friction is used. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef699cd7da0b6e36167e132136c2ed96"></a><!-- doxytag: member="cProxyPointForceAlgo::setMovingObject" ref="ef699cd7da0b6e36167e132136c2ed96" args="(cGenericObject *a_movingObject)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#ef699cd7da0b6e36167e132136c2ed96">setMovingObject</a> (<a class="el" href="classc_generic_object.html">cGenericObject</a> *a_movingObject)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set moving object. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#b8d938b2bef9cedceb5ad8aa66be80af">goalAchieved</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_proxy, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the proxy has reached the goal point.  <a href="#b8d938b2bef9cedceb5ad8aa66be80af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#045b3fbe6abb3e8fa672d91cc4de9a37">offsetGoalPosition</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_goal, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_proxy) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offset the goal to account for proxy volume.  <a href="#045b3fbe6abb3e8fa672d91cc4de9a37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#87beb592bec32f6c5651706936ec1cc5">computeNextBestProxyPosition</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> a_goal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the next goal position of the proxy.  <a href="#87beb592bec32f6c5651706936ec1cc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#af4e5aad1c28e7f7e1328e5fb2cfd2db">testFrictionAndMoveProxy</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;goal, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;proxy, <a class="el" href="structc_vector3d.html">cVector3d</a> normal, <a class="el" href="classc_generic_object.html">cGenericObject</a> *parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to move the proxy, subject to friction constraints.  <a href="#af4e5aad1c28e7f7e1328e5fb2cfd2db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#48ae7c3ef75afee54d581d786faf6d3e">computeForce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute force to apply to device.  <a href="#48ae7c3ef75afee54d581d786faf6d3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#253ccab4bc46c2b2b1f80f0eeaa0af3c">correctProxyForObjectMotion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Let proxy move along with the object it's touching, if object has moved.  <a href="#253ccab4bc46c2b2b1f80f0eeaa0af3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#82fed621cc19d5843f070453e1ddf3ac">updateDynamicContactState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the dynamic proxy state to reflect new contact information.  <a href="#82fed621cc19d5843f070453e1ddf3ac"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8b1b89c663de414731b176c9691a582"></a><!-- doxytag: member="cProxyPointForceAlgo::m_proxyGlobalPos" ref="e8b1b89c663de414731b176c9691a582" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e8b1b89c663de414731b176c9691a582">m_proxyGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global position of the proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="638d0c345486424ba818c79baaebefa2"></a><!-- doxytag: member="cProxyPointForceAlgo::m_deviceGlobalPos" ref="638d0c345486424ba818c79baaebefa2" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#638d0c345486424ba818c79baaebefa2">m_deviceGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global position of device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0b43f42fe9ddbe8ed088077aa19d459"></a><!-- doxytag: member="cProxyPointForceAlgo::m_lastGlobalForce" ref="d0b43f42fe9ddbe8ed088077aa19d459" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d0b43f42fe9ddbe8ed088077aa19d459">m_lastGlobalForce</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Last computed force (in global coordinate frame). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d4a704094a26e4eeba5ac95660f1e28"></a><!-- doxytag: member="cProxyPointForceAlgo::m_nextBestProxyGlobalPos" ref="1d4a704094a26e4eeba5ac95660f1e28" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#1d4a704094a26e4eeba5ac95660f1e28">m_nextBestProxyGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next best position for the proxy (in global coordinate frame). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4305ff140536b66109c974173624e198"></a><!-- doxytag: member="cProxyPointForceAlgo::m_slipping" ref="4305ff140536b66109c974173624e198" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#4305ff140536b66109c974173624e198">m_slipping</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are we currently in a "slip friction" state? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98922c81c2c631b0068159072f0fc807"></a><!-- doxytag: member="cProxyPointForceAlgo::m_normalForce" ref="98922c81c2c631b0068159072f0fc807" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#98922c81c2c631b0068159072f0fc807">m_normalForce</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normal force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9ecb324aa05848daa965100803526af"></a><!-- doxytag: member="cProxyPointForceAlgo::m_tangentialForce" ref="b9ecb324aa05848daa965100803526af" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#b9ecb324aa05848daa965100803526af">m_tangentialForce</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tangential force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e801a3bfb555635771991bc376a4c5b2"></a><!-- doxytag: member="cProxyPointForceAlgo::m_useMelderFriction" ref="e801a3bfb555635771991bc376a4c5b2" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#e801a3bfb555635771991bc376a4c5b2">m_useMelderFriction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the Melder friction algorithm? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05d94278dccf47a77afad0f80e152f7c"></a><!-- doxytag: member="cProxyPointForceAlgo::m_numContacts" ref="05d94278dccf47a77afad0f80e152f7c" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#05d94278dccf47a77afad0f80e152f7c">m_numContacts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of contacts between proxy and triangles (0, 1, 2 or 3). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73e48fd55a2f21d83fa72604343c7ea2"></a><!-- doxytag: member="cProxyPointForceAlgo::m_triangle0" ref="73e48fd55a2f21d83fa72604343c7ea2" args="" -->
<a class="el" href="classc_triangle.html">cTriangle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#73e48fd55a2f21d83fa72604343c7ea2">m_triangle0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to first triangle with which proxy is in contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83bff909e5dc4361a0cbbbd1c34e65bd"></a><!-- doxytag: member="cProxyPointForceAlgo::m_triangle1" ref="83bff909e5dc4361a0cbbbd1c34e65bd" args="" -->
<a class="el" href="classc_triangle.html">cTriangle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#83bff909e5dc4361a0cbbbd1c34e65bd">m_triangle1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to second triangle with which proxy is in contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b5dfaec98903e48ce5232e59f7723ffe"></a><!-- doxytag: member="cProxyPointForceAlgo::m_triangle2" ref="b5dfaec98903e48ce5232e59f7723ffe" args="" -->
<a class="el" href="classc_triangle.html">cTriangle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#b5dfaec98903e48ce5232e59f7723ffe">m_triangle2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to third triangle with which proxy is in contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb7ddb77d45d9428d699e51a04dfd3b2"></a><!-- doxytag: member="cProxyPointForceAlgo::m_touchingObject" ref="eb7ddb77d45d9428d699e51a04dfd3b2" args="" -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#eb7ddb77d45d9428d699e51a04dfd3b2">m_touchingObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the object (if any) with which the proxy is currently in contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c9a5353eab28e9f7cb7445a23d453eac"></a><!-- doxytag: member="cProxyPointForceAlgo::m_movingObject" ref="c9a5353eab28e9f7cb7445a23d453eac" args="" -->
<a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#c9a5353eab28e9f7cb7445a23d453eac">m_movingObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the proxy is associated with a specific moving object... <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="939663abf57d721b2906c89c39790efb"></a><!-- doxytag: member="cProxyPointForceAlgo::m_touchingPoint" ref="939663abf57d721b2906c89c39790efb" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#939663abf57d721b2906c89c39790efb">m_touchingPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Point of contact (if any) between proxy and object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7880ab7335e4584fdf5018fbe61a79e"></a><!-- doxytag: member="cProxyPointForceAlgo::m_colorProxy" ref="c7880ab7335e4584fdf5018fbe61a79e" args="" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#c7880ab7335e4584fdf5018fbe61a79e">m_colorProxy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color of rendered proxy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef4efe80b2efc65d2ff20cf52a2360e1"></a><!-- doxytag: member="cProxyPointForceAlgo::m_colorLine" ref="ef4efe80b2efc65d2ff20cf52a2360e1" args="" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#ef4efe80b2efc65d2ff20cf52a2360e1">m_colorLine</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color of rendered line. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dc9747ecec32cc212bb89283642f126b"></a><!-- doxytag: member="cProxyPointForceAlgo::m_radius" ref="dc9747ecec32cc212bb89283642f126b" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#dc9747ecec32cc212bb89283642f126b">m_radius</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Radius used to display device position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d7a93f3823bacab85d3d07008e5a438d"></a><!-- doxytag: member="cProxyPointForceAlgo::m_displayRadius" ref="d7a93f3823bacab85d3d07008e5a438d" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d7a93f3823bacab85d3d07008e5a438d">m_displayRadius</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Radius used to display the proxy position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d005f99d4a05dd3232d2568b5c8a5d0e"></a><!-- doxytag: member="cProxyPointForceAlgo::m_dynamicProxy" ref="d005f99d4a05dd3232d2568b5c8a5d0e" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#d005f99d4a05dd3232d2568b5c8a5d0e">m_dynamicProxy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic proxy flag (if on, all contacts are computed in object-local space). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="77d18fbb2638e5e990d1d98cf68af628"></a><!-- doxytag: member="cProxyPointForceAlgo::lastIterationPositions" ref="77d18fbb2638e5e990d1d98cf68af628" args="" -->
meshPositionMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#77d18fbb2638e5e990d1d98cf68af628">lastIterationPositions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mapping from meshes to position/rotation info for handling moving objects. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cc2850d9af821c630ddda85eed4826f"></a><!-- doxytag: member="cProxyPointForceAlgo::m_lastObjectGlobalPos" ref="3cc2850d9af821c630ddda85eed4826f" args="" -->
<a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#3cc2850d9af821c630ddda85eed4826f">m_lastObjectGlobalPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic proxy tracks last position of object it's touching at each call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="abcbf71bb73f27ced90e3495dfcf836d"></a><!-- doxytag: member="cProxyPointForceAlgo::m_lastObjectGlobalRot" ref="abcbf71bb73f27ced90e3495dfcf836d" args="" -->
<a class="el" href="structc_matrix3d.html">cMatrix3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_proxy_point_force_algo.html#abcbf71bb73f27ced90e3495dfcf836d">m_lastObjectGlobalRot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic proxy tracks last rotation of object it's touching at each call. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implements the finger-proxy algorithm for computing interaction forces between a point force device and meshes. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e2d00616ad7692c57a06133bfc56631e"></a><!-- doxytag: member="cProxyPointForceAlgo::cProxyPointForceAlgo" ref="e2d00616ad7692c57a06133bfc56631e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cProxyPointForceAlgo::cProxyPointForceAlgo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor of <a class="el" href="classc_proxy_point_force_algo.html" title="Implements the finger-proxy algorithm for computing interaction forces between a...">cProxyPointForceAlgo</a>. 
<p>
Constructor of <a class="el" href="classc_proxy_point_force_algo.html" title="Implements the finger-proxy algorithm for computing interaction forces between a...">cProxyPointForceAlgo</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d7d138be171b9fc353b61d3f53c47d05"></a><!-- doxytag: member="cProxyPointForceAlgo::initialize" ref="d7d138be171b9fc353b61d3f53c47d05" args="(cWorld *a_world, const cVector3d &amp;a_initialPos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_world.html">cWorld</a> *&nbsp;</td>
          <td class="paramname"> <em>a_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_initialPos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the algorithm. 
<p>
Initialize the algorithm, including setting the pointer to the world in which the algorithm is to operate, and setting the initial position of the device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_world</em>&nbsp;</td><td>Pointer to world in which force algorithm is operating. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_initialPos</em>&nbsp;</td><td>Initial position of the device. </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classc_generic_point_force_algo.html#bcd23fc9b1e236d66cff9de138efa105">cGenericPointForceAlgo</a>.
</div>
</div><p>
<a class="anchor" name="ac323ed55414943dfeb8469a9ff07b4c"></a><!-- doxytag: member="cProxyPointForceAlgo::computeForces" ref="ac323ed55414943dfeb8469a9ff07b4c" args="(const cVector3d &amp;a_nextDevicePos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc_vector3d.html">cVector3d</a> cProxyPointForceAlgo::computeForces           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_nextDevicePos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate interaction forces between device and meshes. 
<p>
This method computes the force to add to the device due to any collisions with meshes by calling <a class="el" href="classc_proxy_point_force_algo.html#87beb592bec32f6c5651706936ec1cc5" title="Compute the next goal position of the proxy.">computeNextBestProxyPosition()</a> to update the proxy location and then <a class="el" href="classc_proxy_point_force_algo.html#48ae7c3ef75afee54d581d786faf6d3e" title="Compute force to apply to device.">computeForce()</a> to calculate a force vector based on the proxy location.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_nextDevicePos</em>&nbsp;</td><td>Current position of the device. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return the force to add to the device due to any collisions with meshes. </dd></dl>

<p>
Reimplemented from <a class="el" href="classc_generic_point_force_algo.html#262a15d452a0c534b9bcec6362be3bf0">cGenericPointForceAlgo</a>.
</div>
</div><p>
<a class="anchor" name="3286106325b865928794abca48bee562"></a><!-- doxytag: member="cProxyPointForceAlgo::getContacts" ref="3286106325b865928794abca48bee562" args="(cTriangle *&amp;a_t0, cTriangle *&amp;a_t1, cTriangle *&amp;a_t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cProxyPointForceAlgo::getContacts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_triangle.html">cTriangle</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>a_t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_triangle.html">cTriangle</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>a_t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_triangle.html">cTriangle</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>a_t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of current contacts and the associated triangles. 
<p>
Return the number of current contacts, and the associated triangles in the output parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_t0</em>&nbsp;</td><td>Returns pointer to first contact triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_t1</em>&nbsp;</td><td>Returns pointer to second contact triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_t2</em>&nbsp;</td><td>Returns pointer to third contact triangle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return the number of current contacts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8d938b2bef9cedceb5ad8aa66be80af"></a><!-- doxytag: member="cProxyPointForceAlgo::goalAchieved" ref="b8d938b2bef9cedceb5ad8aa66be80af" args="(const cVector3d &amp;a_proxy, const cVector3d &amp;a_goal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cProxyPointForceAlgo::goalAchieved           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_goal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test whether the proxy has reached the goal point. 
<p>
Test whether the proxy has reached the goal point, allowing for subclass- specific approximations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_goal</em>&nbsp;</td><td>The location to which we'd like to move the proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_proxy</em>&nbsp;</td><td>The current position of the proxy </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true is the proxy has effectively reached the goal </dd></dl>

</div>
</div><p>
<a class="anchor" name="045b3fbe6abb3e8fa672d91cc4de9a37"></a><!-- doxytag: member="cProxyPointForceAlgo::offsetGoalPosition" ref="045b3fbe6abb3e8fa672d91cc4de9a37" args="(cVector3d &amp;a_goal, const cVector3d &amp;a_proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::offsetGoalPosition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_proxy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Offset the goal to account for proxy volume. 
<p>
Offset the current goal position to account for the volume/shape of the proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_goal</em>&nbsp;</td><td>The location to which we'd like to move the proxy, offset upon return </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_proxy</em>&nbsp;</td><td>The current position of the proxy </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="87beb592bec32f6c5651706936ec1cc5"></a><!-- doxytag: member="cProxyPointForceAlgo::computeNextBestProxyPosition" ref="87beb592bec32f6c5651706936ec1cc5" args="(cVector3d a_goal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::computeNextBestProxyPosition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td>
          <td class="paramname"> <em>a_goal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the next goal position of the proxy. 
<p>
Given the new position of the device and considering the current position of the proxy, this function attempts to move the proxy towards the device position (the goal). If its path is blocked by an obstacle (e.g., a triangle in a mesh), the proxy is moved to this intersection point and a new goal is calculated as the closest point to the original goal in the half-plane above the intersection triangle. The process is repeated if necessary, bringing the proxy to its final location.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_goal</em>&nbsp;</td><td>The goal towards which to move the proxy, subject to constraints </td></tr>
  </table>
</dl>

<p>
Initialize normal and tangential forces. 
</div>
</div><p>
<a class="anchor" name="af4e5aad1c28e7f7e1328e5fb2cfd2db"></a><!-- doxytag: member="cProxyPointForceAlgo::testFrictionAndMoveProxy" ref="af4e5aad1c28e7f7e1328e5fb2cfd2db" args="(const cVector3d &amp;goal, const cVector3d &amp;proxy, cVector3d normal, cGenericObject *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::testFrictionAndMoveProxy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to move the proxy, subject to friction constraints. 
<p>
Attempt to move the proxy, subject to friction constraints. This is called from computeNextBestProxyPosition when the proxy is ready to move along a known surface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>goal</em>&nbsp;</td><td>The location to which we'd like to move the proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The current position of the proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normal</em>&nbsp;</td><td>The surface normal at the obstructing surface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>The surface along which we're moving </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="48ae7c3ef75afee54d581d786faf6d3e"></a><!-- doxytag: member="cProxyPointForceAlgo::computeForce" ref="48ae7c3ef75afee54d581d786faf6d3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::computeForce           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute force to apply to device. 
<p>
This method uses the information computed earlier in computeNextProxyPosition() to determine the force to apply to the device. The function computes a force proportional to the distance between the positions of the proxy and the device and scaled by the average stiffness of each contact triangle. 
</div>
</div><p>
<a class="anchor" name="253ccab4bc46c2b2b1f80f0eeaa0af3c"></a><!-- doxytag: member="cProxyPointForceAlgo::correctProxyForObjectMotion" ref="253ccab4bc46c2b2b1f80f0eeaa0af3c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::correctProxyForObjectMotion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Let proxy move along with the object it's touching, if object has moved. 
<p>
This method lets the proxy move along with the object it's touching, if the object has moved since the previous proxy iteration. 
</div>
</div><p>
<a class="anchor" name="82fed621cc19d5843f070453e1ddf3ac"></a><!-- doxytag: member="cProxyPointForceAlgo::updateDynamicContactState" ref="82fed621cc19d5843f070453e1ddf3ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cProxyPointForceAlgo::updateDynamicContactState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the dynamic proxy state to reflect new contact information. 
<p>
This method sets the dynamic proxy state to reflect new contact information. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>chai3d/src/forces/<a class="el" href="_c_proxy_point_force_algo_8h.html">CProxyPointForceAlgo.h</a><li>chai3d/src/forces/CProxyPointForceAlgo.cpp</ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jun 11 09:41:48 2007 for CHAI 3D by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
