<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CHAI 3D: cCollisionSpheres Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>cCollisionSpheres Class Reference</h1><!-- doxytag: class="cCollisionSpheres" --><!-- doxytag: inherits="cGenericCollision" --><a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a> provides methods to create a sphere tree for collision detection, and to use this tree to check for the intersection of a line with a mesh.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;CCollisionSpheres.h&gt;</code>
<p>
<p>Inheritance diagram for cCollisionSpheres:
<p><center><img src="classc_collision_spheres.png" usemap="#cCollisionSpheres_map" border="0" alt=""></center>
<map name="cCollisionSpheres_map">
<area href="classc_generic_collision.html" alt="cGenericCollision" shape="rect" coords="0,0,114,24">
</map>
<a href="classc_collision_spheres-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#9ccc01ba7b7f1e94b68bee2f171545a2">cCollisionSpheres</a> (vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> &gt; *a_triangles, bool a_useNeighbors)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a>.  <a href="#9ccc01ba7b7f1e94b68bee2f171545a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#d71f2c4f993011dbca74688876f950d1">~cCollisionSpheres</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor of <a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a>.  <a href="#d71f2c4f993011dbca74688876f950d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#ed8d1b1ee7a0afa0ad2d82c97dfe8a24">initialize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the sphere tree based on the given triangles.  <a href="#ed8d1b1ee7a0afa0ad2d82c97dfe8a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#a40aa3507dd3dbe99268d31817daf4b6">render</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw the collision spheres in OpenGL.  <a href="#a40aa3507dd3dbe99268d31817daf4b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#cfe41e678783cad3de32549ad229f5fb">computeCollision</a> (<a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointA, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_segmentPointB, <a class="el" href="classc_generic_object.html">cGenericObject</a> *&amp;a_colObject, <a class="el" href="classc_triangle.html">cTriangle</a> *&amp;a_colTriangle, <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_colPoint, double &amp;a_colSquareDistance, int a_proxyCall=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the nearest triangle intersected by the given segment, if any.  <a href="#cfe41e678783cad3de32549ad229f5fb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a532619d4218396cce8dfaa14cbc7eee"></a><!-- doxytag: member="cCollisionSpheres::m_root" ref="a532619d4218396cce8dfaa14cbc7eee" args="" -->
<a class="el" href="classc_collision_spheres_sphere.html">cCollisionSpheresSphere</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#a532619d4218396cce8dfaa14cbc7eee">m_root</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the sphere at the root of the sphere tree. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d423f492c559f53596a35de73d62c241"></a><!-- doxytag: member="cCollisionSpheres::m_trigs" ref="d423f492c559f53596a35de73d62c241" args="" -->
vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#d423f492c559f53596a35de73d62c241">m_trigs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the list of triangles in the mesh. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8ebe42c0fe8f0af9d6662dcf6fc0da68"></a><!-- doxytag: member="cCollisionSpheres::m_lastCollision" ref="8ebe42c0fe8f0af9d6662dcf6fc0da68" args="" -->
<a class="el" href="classc_triangle.html">cTriangle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#8ebe42c0fe8f0af9d6662dcf6fc0da68">m_lastCollision</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triangle returned by last successful collision test. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2aac984b85e5d4ce7aff4508958ef72"></a><!-- doxytag: member="cCollisionSpheres::m_useNeighbors" ref="c2aac984b85e5d4ce7aff4508958ef72" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#c2aac984b85e5d4ce7aff4508958ef72">m_useNeighbors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use neighbor list to speed up collision detection? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf226456d6e29a795aa3d1a5a9269c47"></a><!-- doxytag: member="cCollisionSpheres::m_firstLeaf" ref="cf226456d6e29a795aa3d1a5a9269c47" args="" -->
<a class="el" href="classc_collision_spheres_leaf.html">cCollisionSpheresLeaf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_collision_spheres.html#cf226456d6e29a795aa3d1a5a9269c47">m_firstLeaf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the beginning of list of leaf nodes. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a> provides methods to create a sphere tree for collision detection, and to use this tree to check for the intersection of a line with a mesh. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9ccc01ba7b7f1e94b68bee2f171545a2"></a><!-- doxytag: member="cCollisionSpheres::cCollisionSpheres" ref="9ccc01ba7b7f1e94b68bee2f171545a2" args="(vector&lt; cTriangle &gt; *a_triangles, bool a_useNeighbors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cCollisionSpheres::cCollisionSpheres           </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>a_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_useNeighbors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor of <a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a>. 
<p>
Constructor of <a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_triangles</em>&nbsp;</td><td>Pointer to array of triangles. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_useNeighbors</em>&nbsp;</td><td>Use neighbor lists to speed up collision detection? </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d71f2c4f993011dbca74688876f950d1"></a><!-- doxytag: member="cCollisionSpheres::~cCollisionSpheres" ref="d71f2c4f993011dbca74688876f950d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cCollisionSpheres::~cCollisionSpheres           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor of <a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a>. 
<p>
Destructor of <a class="el" href="classc_collision_spheres.html" title="cCollisionSpheres provides methods to create a sphere tree for collision detection...">cCollisionSpheres</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="ed8d1b1ee7a0afa0ad2d82c97dfe8a24"></a><!-- doxytag: member="cCollisionSpheres::initialize" ref="ed8d1b1ee7a0afa0ad2d82c97dfe8a24" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCollisionSpheres::initialize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the sphere tree based on the given triangles. 
<p>
Build the Sphere Tree collision-detection tree. Each leaf is associated with one triangle and with a bounding sphere of minimal radius such that it fully encloses the triangle. Each internal node is associated with a bounding sphere of minimal radius such that it fully encloses the bounding spheres of its two children. 
<p>
Reimplemented from <a class="el" href="classc_generic_collision.html#930816b6beef87e1735a812b805340a9">cGenericCollision</a>.
</div>
</div><p>
<a class="anchor" name="a40aa3507dd3dbe99268d31817daf4b6"></a><!-- doxytag: member="cCollisionSpheres::render" ref="a40aa3507dd3dbe99268d31817daf4b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cCollisionSpheres::render           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draw the collision spheres in OpenGL. 
<p>
Draw the collision spheres at the given level. 
<p>
Reimplemented from <a class="el" href="classc_generic_collision.html#6d2d7e4f538f1cebe337bbc27e1a26da">cGenericCollision</a>.
</div>
</div><p>
<a class="anchor" name="cfe41e678783cad3de32549ad229f5fb"></a><!-- doxytag: member="cCollisionSpheres::computeCollision" ref="cfe41e678783cad3de32549ad229f5fb" args="(cVector3d &amp;a_segmentPointA, cVector3d &amp;a_segmentPointB, cGenericObject *&amp;a_colObject, cTriangle *&amp;a_colTriangle, cVector3d &amp;a_colPoint, double &amp;a_colSquareDistance, int a_proxyCall=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cCollisionSpheres::computeCollision           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_segmentPointB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_generic_object.html">cGenericObject</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>a_colObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classc_triangle.html">cTriangle</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>a_colTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_colPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a_colSquareDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>a_proxyCall</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the nearest triangle intersected by the given segment, if any. 
<p>
Check if the given line segment intersects any triangle of the mesh. If so, return true, as well as (through the output parameters) pointers to the intersected triangle, the mesh of which this triangle is a part, the point of intersection, and the distance from the origin of the segment to the collision point. If more than one triangle is intersected, return the one closest to the origin of the segment. The method uses the pre-computed sphere tree, starting at the root and recursing through the tree, breaking the recursion along any path in which the sphere bounding the line segment does not intersect the sphere of the node. At the leafs, triangle-segment intersection testing is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointA</em>&nbsp;</td><td>Initial point of segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_segmentPointB</em>&nbsp;</td><td>End point of segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colObject</em>&nbsp;</td><td>Returns pointer to nearest collided object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colTriangle</em>&nbsp;</td><td>Returns pointer to nearest collided triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colPoint</em>&nbsp;</td><td>Returns position of nearest collision. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_colSquareDistance</em>&nbsp;</td><td>Returns distance between ray origin and collision point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_proxyCall</em>&nbsp;</td><td>If this is &gt; 0, this is a call from a proxy, and the value of a_proxyCall specifies which call this is. When checking for the second and third constraint planes, only the neighbors of the triangle intersected in the first call need be checked, not the whole tree. Call with a_proxyCall = -1 for non-proxy calls. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return true if the line segment intersects a triangle. </dd></dl>

<p>
Reimplemented from <a class="el" href="classc_generic_collision.html#874e55d08dbb031f8382e2b4855b820e">cGenericCollision</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>chai3d/src/collisions/<a class="el" href="_c_collision_spheres_8h.html">CCollisionSpheres.h</a><li>chai3d/src/collisions/CCollisionSpheres.cpp</ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jun 11 09:41:46 2007 for CHAI 3D by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
